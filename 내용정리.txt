20230605

시작시
npm start

1. jsx에서는 class 명을 부여할 때 class가 아닌
className으로 클래스명을 부여한다.
2. jsx에서는 변수 넣을 때는 {}로 삽입 - 데이터바인딩
3. 인라인으로 style을 삽입 할 때는 {{fontSize:""}} 이런식


state

자료를 잠깐 저장할 때는 state를 써도 된다.
state는 자동으로 html이 재랜더링이 된다.

state 변경하는 법
setstate 변경함수를 사용을 해야 html이 재랜더링이 된다.


20230606
스프레드 오퍼레이트

state의 특징은 
기존 state == 신규 state의 경우 변경을 안해줌
array랑 object는 선언하면 직접 데이터를 저장하는 것이
아니라 저장된 곳으로 가는 화살표라고 생각을 하면됩니다.

스프레드 오퍼레이트 [...] 은 괄호를 벗겨주고
새로운 배열로 만들어준다 즉 복사를 해주고 사본을 만들어준다.
객체도 만들어준다.


컴포넌트를 만들면 좋을 거 같은 경우

1.반복적으로 html 축약할 때
2.큰페이지들
3.자주변경되는 것들


20230607
pros 복습
<자식 컴포넌트 작명={state이름}/>


그다음

function 자식 컴포넌트({state이름}){
  return{
    <div>
    {state이름}
    </div>
  }
}
이런식으로 어디든 사용가능

function Modal(props){
  return (
    <div className="modal">
      <h4>{ props.글제목[0] }</h4>
      <p>날짜</p>
      <p>상세내용</p>
    </div>
  )
}

state는 state를 사용하는 컴포넌트 중 최고 부모에 만들어놓아야한다.



20230608
보통 리액트 사이트 배포전에 전부 압축하지만
수백장에 이미지
public 폴더 안에 있던 곳은 그냥/ 이미지경로에 넣으면된다.
문제는 서브 경로에 이미지를 넣어야할 때
/ 서브폴더/이미지


하지만 권장되는 방식은 이렇게입니다. 
왜냐면 리액트로 만든 html 페이지를 배포할 때
codingapple.com 경로에 배포하면 아무런 문제가 없지만
codingapple.com/어쩌구/ 경로에 배포하면
/logo192.png 이렇게 쓰면 파일을 찾을 수 없다고 나올 수도 있습니다. 
그래서 /어쩌구/ 를 뜻하는 process.env.PUBLIC_URL 이것도 더해주면 된다고 하는군요. 


codingapple.com/어쩌구/ 경로에 리액트로 만든 페이지를 배포할 일이 아예 없으면 굳이 안해도 됩니다. 


<img src={process.env.PUBLIC_URL + '/logo192.png'} />

process.env.PUBLIC_URL  << 내사이트의 경로를 뜻하고


20230609
라우트 
react-router-dom 패키지 파일 설치하고
index.js 처럼 셋팅


  let navigate = useNavigate();
  /* 페이지 이동 */
  /* 보통 함수를 담아서 사용 */
  Link 태그가 아닌 일반 onClick 이벤트에 달아서 라우팅 진행


  nasted router
  <Route path="/ShopPage" element={<ShopPage />}>
    <Route path="/shopPageDetail" element={<ShopPageDetail />} />
    {/* nasted router 
    /ShopPage/shopPageDetail
    */}
  </Route>

 이러면  ShopPage 이컴포넌트 밑에 ShopPageDetail 이걸 보여줌
 둘다 한 화면에 보여줌


  nasted router 이거 왜필요할까
  여러 페이지를 만들때
  여러 유사한 페이지를 만들때



  url 파라미터

  상세 페이지를 수십만개를 만들어야 하는데 하나하나 사이트를 만들 수 없음
  그래서 url 파라미터를 쓴다.

            <Route
            path="/ShopPage/shopPageDetail/:id"
            /ShopPage/shopPageDetail/:id<<< 아무거나
            element={<ShopPageDetail shopData={shopData} />}
          >

          :id 이런식으로


          import { useParams } from 'react-router-dom'

          let 변수명 = useParams();
          이런식으로 식으로 쓰면 파라미터url을 쓸 수 있다 


                      /ShopPage/shopPageDetail/:id/:작명은 자유롭게 제한없이 여러개 사용가능


20230610
lifeCycle hook 
라이프 사이클
컴포넌트 사람 처럼 살고 죽는다.

컴포넌트가 보이는 순간 mount된다.
가끔 state가 조작이 된다? update가 된다.
필요 없으면 제거가 된다. unmount

이거를 왜 배워?
중간중간 간섭이 가능 즉 중간 중간 코드 실행이 가능


    useEffect가 있는 함수는 그 컴포넌트가 장착(마운트)가 되거나
    업데이트가 될 때 useEffect 안에 있는 것들이 작동한다.
    
    useEffect 안에 있는 코드는 그냥 두번 도는 게 정상임 페이지 발행하면 정상작동함

    useEffect 쓰는 이유
    useEffect 실행 시점이 다르다
    useEffect 안에 있는 코드는 html들이 랜더링이 되고 실행이 된다.
    html이 먼저 보여주면 속도가 빨라짐

   useEffect 안에 쓰는 코드들 종류
   어려운 연산
   서버에서 데이터 가져오는 작업 ajax axios
   타이머들

   왜 이름이 useEffect라는 이름을 붙였을까
   사이드 이펙트 함수 핵심과 관련는 부가 기능
   useEffect에 들어가는 []는 디팬더시
   디팬더시에는 스테이트나 변수를 넣을 수 있는데
   디펜더시를 넣으면 디팬더시 안에 있는 state나 변수가 변하면 작동을 한다,
   디팬더시를 비워 놓고 [] 넣은 상태로 두면 useEffect가 장착 즉 mount에만 실행이 된다.

   useEffect(()=>{

   안에 아래처럼 리턴문을 작성을 할 수 있는데 리턴 안에 있는 코드는 useEffect가 동작 전에 작동한다.

     return ()=>{
      보통 타이머를 작성하면 재랜더링 될 때 마다 타이머 갯수가 계속 추가가 되는데 초기화를 처리해주는 것이 좋다.
      ajax 통신 같은 것도...
      여기 사용하는 것을 clean up function

      참고로 clean up function은 mount시 실행이 안됨 unmount시 실행이 됨
    }

   },[])



   그냥 쉽게 외우기 정리 
   
   1.재랜더링 때마다 코드를 실행하고 싶으면 useEffect(()=>{})
   2. mount시 한번만 실행을 하고 싶으면 useEffect(()=>{},[])
   3. 삭제 될 때 한번 useEffect(()=>{
    return ()=>{
       unmount시 삭제
    }
   },[])
   4. 실행 전에  사용하고 싶으면
   useEffect(()=>{
    return ()=>{
      여기에
    }
   },[])
   5 디팬더시에 변수나 state를 넣으면 넣은 state나 변수가 변경시에만 실행함
   useEffect(()=>{
    return ()=>{

    }
   },[여기 넣으면 ])


20230611

서버: 부탁하면 진짜로 들어주는 프로그램

서버통신

1.방법(get,post) 정하고
2.어떤자료(url) 적어 보내라

axios 사용해라

axios post 서버로 데이터 보내는 법
axios.post('URL', {name : 'kim'})

동시에 ajax get 처리하는 법

Promise.all( [axios.get('URL1'), axios.get('URL2')] )


생 자바스크립트에서 통신법 fetch
fetch('URL').then(결과 => 결과.json()).then((결과) => { console.log(결과) } ) JSON -> object/array 변환작업
이런식으로 json 변환 작업이 필요함



        /* 전환 애니메이션 만들기 */
        /* 1.애니메이션 동작 전 className 만들기 */
        /* 2.애니메이션 동작 후 className 만들기 */
        /* 3. className에 transition 속성 추기 */
        /* 4. 원할 때 2번 className 추가 */


    /* useEffect 애니메이션을 적용할 때 이런식으로 타이머를 줘야한다 */
    /* 리액트의 automatic batching 기능 */
    /* 스테이트 변경 함수를 쓸 때마다 재랜더링을 해주는 게 아니라 변경이 전부 되고 나서 마지막에 재랜더링을 해줘야 한다.
    즉 미세한 시간차를 주면 애니메이션이 가능 
    */
    


    Single Page Application 문제는 state 값 공유가 힘들다.
    
    컴포넌트 간 state 공유 어려움
    부모에서 자식 공유는 가능함
    그래서 보통은 중첩 프롭스 계속해서 사용해야 하는데
    그것이 싫다면

    1.Context API(리액트 기본 문법)
    2.Redux등을 사용가능


1.Context API

단점 
1. state 변경시 쓸데없는 컴포넌트까지 전부 재렌더링이 되고 
2. useContext() 를 쓰고 있는 컴포넌트는 나중에 다른 파일에서 재사용할 때 Context를 import 하는게 귀찮아질 수 있습니다.
그래서 이것 보다는 redux 같은 외부라이브러리를 많이들 사용합니다.
걍 이거 쓰지마
    
